= SimpleCi

SimpleCi is a rails app designed to build and test other apps/projects (anything in a git repo), particularly those with large test suites.  All SimpleCi is, is a git repo observer and a command line runner, with some duck grease to make it go real quick.  

You create a 'Project' and define a git repo to be tracked, then add some 'actions' to the project.  An Action is any command line command which you could run in the root dir of your repo, ie: <tt>rake spec</tt>.  Actions also have a 'result_matcher' which will be used to interpret the output from the command.  Each action will get its own instance of the project dir and is executed in its own thread, enabling all the actions for a project to be processed in parrallel.


This is still very much under development.  

===Limitations

* only works with git repos.  
* currently file paths work on unix systems only

==Setup and Usage

===Getting it running
Clone SimpleCi and run a rake setup task to create and migrate the database.  

    git clone git@github.com:Sujimichi/SimpleCi.git
    cd SimpleCi
    rake setup


To run SimpleCi you need *both* the app server and the 'runner'.  I prefer to run these in separate terms but you can just run;

    rails s -p 3333 & rake runner

Use a different port on the rails server to leave the normal 3000 free for your development.

The runner (lib/runner.rb) is responsible for periodically checking the tracked repos for updates to then running the actions.  This component is not ideal but has repalced a previous implementation involving background workers which was problematic due to environment variables.  see discussion later.

===Usage
Once the rails server and runner are started use the interface to create a "Project".  A project has a name(optional) and a source_path which should reference the git repo you want to track.  (There may come options for tracking specific branches, for now its just master).  

A project also has 'setup' and 'update' commands given as a string with commands separated by a new line.  When a project is created the source repo is cloned into a specific project folder (in ~/simple_ci/project_<id>/<repo_name>) and any setup commands will be run in the root of the cloned repo.  Each time the source repo is changed the changes are pulled to the projects folder and the update commands are run.
The default setup and update commands are aimed at initializing and updating a rails app;

    project.setup_commands  #=> "bundle install\nbundle exec rake db:create:all\nbundle exec rake db:migrate\nbundle exec rake db:test:prepare"
    project.update_commands #=> "bundle exec rake db:migrate\nbundle exec rake db:test:prepare"

Change these commands to fit how you want to build your poject each time.  With these above commands the repo is updated an recent migrations are run.  Perhaps you want to drop and rebuild the DB from scratch on each update and maybe delete a specific folder, ie;

    project.update_commands #=> "rm -rf tmp\nbundle exec rake db:drop:all\nbundle exec rake db:create:all\nbundle exec rake db:migrate\nbundle exec rake db:test:prepare"


Finally you need to add some Actions to the project.  Each action simply defines a command line command ie; 'rake spec' and which result matcher to use to interpret the results.  For now you can only select from two inbuild result matchers :rpsec and :cucumber but these will become a user definable component.  see more on Result Matchers later.  You can add actions while creating the project or add them later.  Note; Actions added later are not "active" by default and need enabling by clicking on them on the projects page.  Actions can be togglled active/disabled at anytime, disabled actions are not run when the project updates. 


    

===Console Usage

    project = Project.create!(:name => "my project", :source_path => "/home/sujimichi/code/rails/simple_project")
    project.actions.create!(:command => "bundle exec rspec spec/models/*.rb", :result_matcher => :rspec)
    project.actions.create!(:command => "bundle exec rspec spec/controllers/*.rb", :result_matcher => :rspec)
    project.actions.create!(:command => "bundle exec cucumber -p all", :result_matcher => :cucumber)

 

====Result Matchers
The notion of SimpleCi as a generic command line runner rather than a specific test runner, means interpretation of the result from commands is disconnected from the main program logic.  Any command output can be interpreted, it just requires a ResultMatcher to be defined.  Currently ResultMatchers are current defined in code (app/helpers/result_matcher.rb) but they will become user definable via the interface.  

A ResultMatcher is simply a block (wrapped in a class) which passes in two variables; the string returned from the command as results and a hash called output.  Within the block you can make assertions about the content of the results and populate outout accordingly.  output must has a key :status and this should be populated with either :success or :failure.  As well as :status output can have :summary, :time, :message keys which will be displayed in the interface. 

Here is an example of a matcher:

    class RspecMatcher < ResultMatcher
      def process
        @result.evaluate_results do |result, output|
          output[:status] = :failure
          return output if result.blank?
    
          output[:summary] = result.split("\n").select{|line| line.match(/^(\d+) examples/) }.join
          output[:time] = result.split("\n").select{|line| line.match(/^Finished in/)}.join.sub("Finished in","")
    
          if output[:summary].include?("0 failures")
            output[:status] = :success
          else
            output[:status] = :failure
          end
        end
      end
    end






